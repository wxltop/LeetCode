记录力扣刷题进度。难度中，一颗:star2:表示`容易`，两颗:star2::star2:表示`中等`，三颗星:star2::star2::star2:表示`困难`。FM表示`Fully Mastered`表示是否完全掌握。
|线性表|二叉树|动态规划|贪心|回溯|占位符|占位符|占位符|占位符|
| :------------------------: | :------------------------------: | :--------------------: | :--------------------: | :----------------------------------: | :----------------------: | :----------------------: | :--------------------------: | :--------------------------: |
| [:sunflower:](#sunflower-线性表) | [:four_leaf_clover:](#four_leaf_clover-二叉树) | [:deciduous_tree:](#deciduous_tree-动态规划) | [:evergreen_tree:](#evergreen_tree-贪心) | [:cactus:](#cactus-回溯) | [:cherry_blossom:](#cherry_blossom-占位符) | [:maple_leaf:](#maple_leaf-占位符) |   [:palm_tree:](#palm_tree-占位符)   |   [:seedling:](#seedling-占位符)|
# :sunflower: 线性表
|**Problem**|**Difficulty**|**Tags***|**Methods****|**Time**|**Space**|**FM**|**Note**|
| --------- | :----------: |---------| ---------- | :-----: | :-----: | :--: | ------ |
|[21.合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)|:star2:|`链表`|[1.双指针](https://leetcode.cn/submissions/detail/392819406/)<br />[2.简化后的代码](https://leetcode.cn/submissions/detail/392830186/)<br />[3.递归](https://leetcode.cn/submissions/detail/392837384/)|$O(n)$<br />$O(n)$<br />$O(n+m)$|$O(1)$<br />$O(1)$<br />$O(n+m)$|:white_check_mark:|注意哨兵节点的灵活使用，可以简化代码。递归思路：每一步合并操作都是将俩子链表较小的一个头结点合并过来，然后处理后续的节点，即head1.val+merge(head1.next, head2) 或者 head2.val+merge(head1, head2.next)|
|[86.单链表的分解](https://leetcode.cn/problems/partition-list/)|:star2::star2:|`链表`|[1.双指针](https://leetcode.cn/submissions/detail/393068538/)<br />[2.大小链表](https://leetcode.cn/submissions/detail/393075051/)|$O(n)$<br />$O(n)$<br />$O(n+m)$|$O(1)$<br />$O(1)$<br />$O(n+m)$||两种方法效率差不多，只不过处理逻辑有差别，双指针逻辑更复杂，双指针用指针从输入链表中取出较小节点插入所维护的链表中；大小链表维护两个链表，分别存储小值的节点和大值的节点，逻辑更容易理解|
|[23.合并k个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)|:star2::star2::star2:|`链表`|[1.多指针](https://leetcode.cn/submissions/detail/393109365/)<br />[2.顺序合并](https://leetcode.cn/submissions/detail/393285831/)<br />[3.分治合并](https://leetcode.cn/submissions/detail/393297388/)|$O(k^2n+k^2/2)$<br />$O(k^2n)$<br/>$O(knlogk)$|$O(1)$<br />$O(1)$<br />$O(logk)$||多指针维护k个指针分别指向k个链表，循环每次从k个链表中获取当前层的最小值然后插入结果链表，当所有指针为空时退出循环。顺序合并先解决两个顺序链表的合并问题，然后按顺序两两合并。分治合并使用分治算法完成。官方解读还有一种[优先队列(二叉堆)](https://leetcode.cn/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/)的方法，该方法和多指针法很相似，只不过其用一个堆维护k个链表头最小值，而多指针直接用传进来的plist，每次都要选最小值，链表为空时删除。|
|[19.删除链表的倒数第n个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)|:star2::star2:|`链表`|[1.O(L)空间复杂度](https://leetcode.cn/submissions/detail/393109365/)<br />[2.计算链表的长度](https://leetcode.cn/submissions/detail/393691518/)<br />[3.双指针](https://leetcode.cn/submissions/detail/393764158/)|$O(L)$<br/>$O(2L-n+1)$<br/>$O(L)$ | $O(L)$<br />$O(1)$<br/>$O(1)$||双指针比较巧妙，两个指针间隔n-1|
 |[876.链表的中间节点](https://leetcode.cn/problems/middle-of-the-linked-list/)|:star2:|`链表`<br/>`快慢指针`|[1.双指针](https://leetcode.cn/submissions/detail/393788629/)<br/>[2.快慢指针](https://leetcode.cn/submissions/detail/393795468/)|$O(n)$<br/>$O(n/2)$ |$O(1)$<br/>$O(1)$ ||双指针的思路是用一个指针一直往后遍历，另一个指针始终指向中间节点；快慢指针的思路是快指针每次跑两个节点，慢指针每次跑一个节点，所以慢指针始终处于中间位置|
|[141.环形链表](https://leetcode.cn/problems/linked-list-cycle/)|:star2:|`链表`<br/>`快慢指针`|[1.快慢指针](https://leetcode.cn/submissions/detail/394187671/)<br/>[2.哈希表](https://leetcode.cn/submissions/detail/394218224/)|$O(n)$<br/>$O(n)$ |$O(1)$<br/>$O(n)$ ||**可证明：慢指针进入环后第一圈内必定与快指针相遇；快指针速度为慢指针的n倍，二者相遇时间不随n增大而减少**|
|[142.环形链表II](https://leetcode.cn/problems/linked-list-cycle-ii/)|:star2::star2:|`链表`<br/>`快慢指针`|[1.快慢指针](https://leetcode.cn/submissions/detail/394251424/)<br/>[2.哈希表](https://leetcode.cn/submissions/detail/394219009/)|$O(n)$<br/>$O(n)$ |$O(1)$<br/>$O(n)$ ||快慢指针思想是利用快指针和慢指针可以计算出慢指针距离环的入口的长度，设为c，设链表距离环入口长度为a，可以得到a=(n-1)L+c，也就是说重新定义一个指针从链表头开始走，慢指针继续走下去，二者一定会相遇且第一次相遇点在环的入口处。|
|[160.相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)|:star2:|`链表`|[1.双指针](https://leetcode.cn/submissions/detail/394490567/)<br/>[2.哈希表](https://leetcode.cn/submissions/detail/394282945/)|$O(n-m+a)$<br/>$O(n+m)$ | $O(n)$<br/>$O(1)$||双指针方法较巧妙，先从各自头部开始，短链表结束后从长链表出发，长链表走完后从短链表出发，此时二者剩余步长相等，接下来每一步都判断一下是否相等即可。简化代码可以考虑到，结束程序的时候是二者相等，不论是None还是相交|
|[206.反转链表](https://leetcode.cn/problems/reverse-linked-list/)|:star2:|`链表`|[1.栈](https://leetcode.cn/submissions/detail/394901007/)<br/>[2.多指针](https://leetcode.cn/submissions/detail/394951064/)<br/>[3.双指针](https://leetcode.cn/submissions/detail/394982734/)<br/>[4.递归](https://leetcode.cn/submissions/detail/395327986/)<br/>[5.特殊双指针](https://leetcode.cn/submissions/detail/395529053/)|$O(2n)$<br/>$O(n)$<br/>$O(n)$<br/>$O(n)$<br/>$O(n)$ | $O(n)$<br/>$O(1)$<br/>$O(1)$<br/>$O(n)$<br/>$O(1)$||2.多指针和3.双指针思路差不多，但是多指针的实现不够简洁|
|[92.反转链表II](https://leetcode.cn/problems/reverse-linked-list-ii/)|:star2::star2:|`链表`|[1.特殊双指针](https://leetcode.cn/submissions/detail/395610365/)<br/>[2.一次遍历](https://leetcode.cn/submissions/detail/395617734/)|$O(n)$<br/>$O(n)$ | $O(1)$<br/>$O(1)$||特殊双指针是基于206.反转链表完成的，先找到需要反转的子链表头结点和尾节点，返回翻转后的链表，再接上。这样方法的缺点是，如果left和right区间很大，则耗时。方法2就是解决这个问题，一次遍历。起初我自己的想法是，到了left开始翻转，记录left前一个节点，反转到right结束，记录right下一个节点，然后拼接。但是官方给的思路是，在翻转区域内，将后一个节点插到翻转区域的头部。这里代码实现的是官方的思路。官方实现的一次遍历在返回结果的时候不用分类讨论，也就是常遇到的特殊情况问题。|
|[24.两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)|:star2::star2:|`链表`|[1.多指针](https://leetcode.cn/submissions/detail/396174197/)<br/>[2.递归](https://leetcode.cn/submissions/detail/396508688/)|$O(n)$<br/>$O(n)$ | $O(1)$<br/>$O(n)$|||
|[25.K个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)|:star2::star2::star2:|`链表`|[1.多指针](https://leetcode.cn/submissions/detail/396587930/)<br/>|$O(n)$ | $O(1)$||此题要先知道接下来是否有k个节点才决定是否翻转。如果不提前计数，最终还需要还原不足的k个节点。一种方式是翻转前统计整个链表节点数，决定需要翻转的子链表数目；一种方式是每次翻转子链表前统计是否够k个。|
|[328.奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)|:star2::star2:|`链表`|[1.多指针](https://leetcode.cn/submissions/detail/396590304/)<br/>|$O(n)$ | $O(1)$||用一个计数器判断当前是奇数还是偶数，奇数就将当前节点连接到奇数链表上，偶数就将当前节点连接到偶数链表上。|
|[203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)|:star2:|`链表`|[1.多指针](https://leetcode.cn/submissions/detail/396591269/)<br/>|$O(n)$ | $O(1)$|||
|[82.删除排序链表中的重复元素ii](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)|:star2::star2:|`链表`|[1.多指针](https://leetcode.cn/submissions/detail/396648104/)<br/>|$O(n)$ | $O(1)$|||
|[148.排序链表](https://leetcode.cn/problems/sort-list/)|:star2::star2:|`链表`|[1.多指针](https://leetcode.cn/submissions/detail/396651065/)<br/>|$O(n^2)$ | $O(1)$||这种方法无法通过所有案例，最后几个超时|
|[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)|:star2:|`链表`|[1.双指针](https://leetcode.cn/submissions/detail/402038306/)<br/>|$O(n)$ | $O(1)$||可以使用双指针，快指针提前走K个，然后再一起走，快指针到达链表尾部时，返回慢指针即可|


# :four_leaf_clover: 二叉树
|**Problem**|**Difficulty**|**Tags***|**Methods****|**Time**|**Space**|**FM**|**Note**|
| --------- | :----------: |---------| ---------- | :-----: | :-----: | :--: | ------ |
|[144.二叉树前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)|:star2:|`二叉树`|[1.递归](https://leetcode.cn/submissions/detail/402392301/)<br/>[2.循环](https://leetcode.cn/submissions/detail/402390893/) <br/>[3.递归(不依赖语言特性)](https://leetcode.cn/submissions/detail/403367833/)|$O(n)$<br/>$O(n)$ <br/>$O(n)$ | $O(logn)$<br/>$O(1)$ <br/>$O(n)$||前序先访问根节点，故不需要循环走到底入栈节点。只需每一步先输出根节点的值，然后判断右节点是否为空，入栈，判断左节点是否为空，入栈，进入下一次循环。1.用到了链表的合并，依赖于Python的语言特性，3.用一个全局列表避免列表的合并操作，不依赖于语言特性。|
|[144.二叉树中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/submissions/)|:star2:|`二叉树`|[1.递归](https://leetcode.cn/submissions/detail/402396554/)<br/>[2.循环](https://leetcode.cn/submissions/detail/402710303/)<br/> [3.Morris](https://leetcode.cn/submissions/detail/403071324/) <br/> [4.访问标记法](https://leetcode.cn/submissions/detail/403357397/)|$O(n)$<br/>$O(n)$<br/>$O(n)$<br/>$O(n)$ | $O(n)$<br/>$O(n)$<br/>$O(1)$<br/>$O(n)$||2.循环：中序根节点不会马上访问，所以需要入栈，先访问左节点，用一个指针cur指向左节点，循环一直走到其最左边，历经节点入栈，到底后开始出栈，若右节点不为空，修改cur指向右节点。需要注意的是cur不能指向已经入栈过的节点，避免死循环。3.Morris：改法改进循环法，将空间复杂度缩小为O(1)，思路是找到根节点左子树最靠右（最后一个访问）的节点，该节点的右趋节点设置为根节点，这样保证了可以回来从而顺利访问右子树。4.访问标记法：访问过的节点用黑色标记，未访问的用白色标记，若节点为白色，将其左右节点以及本身入栈（顺序依据前中后序遍历二叉树而定），若为黑色，输出值。这种方法可以用于前中后序遍历二叉树，且改动少，思路简单。|
|[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)|:star2:|`二叉树`|[1.递归](https://leetcode.cn/submissions/detail/402728358/)<br/>[2.数层数](https://leetcode.cn/submissions/detail/402733596/) <br/>[3.广度优先](https://leetcode.cn/submissions/detail/403363182/)|$O(n)$<br/>$O(n)$ <br/>$O(n)$| $O(height)$<br/>$O(n)$ <br/>$O(n)$||数层数法指的是每走一层，将该层所有非空节点存入一个列表，随后将该列表存入总列表，每一次从总列表的最后一个列表中访问内部所有节点是否有左右节点，若有，新建一个列表（新的一层），否则返回总列表的项数（即层数）。3.广度优先：思路和数层数法类似，只是每次将前一层的节点都pop掉，降低了空间复杂度为O(n)的概率|
|[543.二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)|:star2:|`二叉树`|[1.递归](https://leetcode.cn/submissions/detail/403381116/)<br/>[2.]()|$O(n)$<br/>$O()$ | $O(n)$<br/>$O()$||递归方法再好好复习一下|
|[1008.前序遍历构造二叉搜索树](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)|:star2::star2:|`二叉树`|[1.递归](https://leetcode.cn/submissions/detail/408316011/)<br/>[2.]()|$O(n)$<br/>$O()$ | $O(n)$<br/>$O()$||搜索树即左子树所有值严格小于根，右子树所有值严格大于根节点。前序遍历序列第一个值为根，所有小于该值的在左子树，大于该值的在右子树，根据这一递归思路可以求解。|
|[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)|:star2::star2:|`二叉树`|[1.递归](https://leetcode.cn/submissions/detail/409808626/)<br/>[2.]()|$O(n)$<br/>$O()$ | $O(n)$<br/>$O()$|||


# :deciduous_tree: 动态规划
|**Problem**|**Difficulty**|**Tags***|**Methods****|**Time**|**Space**|**FM**|**Note**|
| --------- | :----------: |---------| ---------- | :-----: | :-----: | :--: | ------ |
|[5.最长回文串](https://leetcode.cn/problems/longest-palindromic-substring/)|:star2::star2:|`动归`|[1.动归](https://leetcode.cn/submissions/detail/439847008/)<br/>[2.中心扩散](https://leetcode.cn/submissions/detail/441003034/)<br/>[3.马拉车算法]()|$O(n^2)$<br/>$O(n^2)$ | $O(n^2)$<br/>$O(n)$ ||动归的思路是自底向上；中心扩散主要看实现方式，我自己的实现方式是用了递归，递归栈深度为n，官方使用循环实现，所以空间复杂度为 $O(1)$,而且我自己实现的时候check 函数返回的是子串，最好返回的是索引，如果是列表那么空间复杂度将很大，子串虽然不会复制一份，但是习惯要养好. 动归需要枚举的子串个数为 $n^2$ ，而中心扩散需要枚举的子串个数为 $2(n-1)$，所以动归实际上时间要久一点，本题还是看一下官方题解的视频讲解收获更大。|





# :evergreen_tree: 贪心
|**Problem**|**Difficulty**|**Tags***|**Methods****|**Time**|**Space**|**FM**|**Note**|
| --------- | :----------: |---------| ---------- | :-----: | :-----: | :--: | ------ |
|[455.分发饼干](https://leetcode.cn/problems/assign-cookies/)|:star2:|`贪心`|[1.贪心](https://leetcode.cn/submissions/detail/441732467/)<br/>[2.]()|$O(mlogm + nlogn)$<br/>$O()$ | $O(logm+logn)$<br/>$O()$||方法1是自己想的，每次将最大的饼干分发给胃口最大的孩子，下一次分发的时候从剩下的孩子开始分发，分发的时间复杂度为 $O(m+n)$ ，空间复杂度为 $O(1)$ ，排序的时间复杂度为 $O(mlogm+nlogn)$ ，空间复杂度为: $O(logm+logn)$|
|[376.摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)|:star2::star2:|`贪心`|[1.贪心](https://leetcode.cn/problems/wiggle-subsequence/submissions/)<br/>[2.动归](https://leetcode.cn/problems/wiggle-subsequence/submissions/)|$O(n)$<br/>$O(n)$ | $O(1)$<br/>$O(n)$||本题最重要的两个需要考虑的地方：1. 最后一个元素默认为摆动; 2. 单调坡会破坏最初的规则. 所以主要是思考的思路要对，思路就是：将非摆动点去掉，然后再数剩余的,  这样思考的话就容易理解，为啥平坡和单调坡对结果影响不同, 为了防止单调坡会破坏规则，使用两个变量来存储前一个摆动的左右. 动归需要维护up和down两个变量，建议直接看官方解释, 改进的话可以将原本的up和down列表改为变量，减少空间复杂度。|
|[53.最大子数组和](https://leetcode.cn/problems/maximum-subarray/)|:star2::star2:|`贪心`|[1.暴力](https://leetcode.cn/submissions/detail/446735065/)</br> [2.贪心](https://leetcode.cn/submissions/detail/446754696/)<br/>[2.动归]()|$O(n^2)$<br/>$O(n)$<br/>$O(n)$ | $O(1)$<br/>$O(1)$<br/>$O(n)$||贪心方法主要是思想，没有固定模板，比如先做出来暴力解法，然后贪心思路就用于优化。暴力解法就是如何遍历所有的子字符串，按顺序定字符串的起点，然后按顺序定终点。贪心思路就一点：一旦发现子串总和<=0，则从下一个元素开始遍历，我按照这个思路自己实现的是双重循环的格式，但是其实复杂度只有$O(n)$，参考答案才知道等价于一重循环。动归的helper[i]并不是存的截止i，最大子数组和，即最终结果不是直接返回helper[i]，如果这样思考的话会很麻烦，因为最大子数组可能在中间，可能包含端点，得分类讨论，换一种思路：helper[i-1]>0时，表示正处于某一个子数组中，若helper[i-1]<0，则后面的数加上<0的一定会更小，就不是最大，该子数组停止延伸，记下该子数组的和，下一个子数组的第一个元素为nums[i]|
|[122.买卖股票的最佳时机2](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)|:star2::star2:|`贪心`|[1.贪心](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/submissions/449020970/)<br/>[2.动归](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/submissions/449062587/)|$O(n)$<br/>$O(n)$ | $O(1)$<br/>$O(n)$||总的思路：每一天都买入，如果明天比今天高，则明天卖出，如果明天比今天低，则今天卖出，保证每一天不会有负增长。动归的helper[i]表示，到第i天的最大收益|


# :cactus: 回溯
|**Problem**|**Difficulty**|**Tags***|**Methods****|**Time**|**Space**|**FM**|**Note**|
| --------- | :----------: |---------| ---------- | :-----: | :-----: | :--: | ------ |
|[46. 全排列](https://leetcode.cn/problems/permutations/)|:star2::star2:|`回溯`|[1.回溯](https://leetcode.cn/submissions/detail/419087027/)<br/> [2.优化空间复杂度](https://leetcode.cn/submissions/detail/419116598/)|$O(n \cdot n!)$<br/>$O(n \cdot n!+2n)$ | $O(n \cdot n!)$<br/>$O(n \cdot n!)$||递归算法的用时和内存消耗与递归树的节点数紧密相关，递归树的非叶子结点与叶子结点的行为不同。非叶子结点中，第$i$层递归树结点数为 $A^i_{n}$ ，所以仅仅看递归树的深度，每一个叶子结点的计算用时<2n!，而每一个叶子结点中也循环了n次，所以非叶子结点的时间复杂度为 $O(n \cdot n!)$ 。最后一层有n!个叶子结点，每一个叶子结点都要进行一次拷贝，所以叶子结点的用时也为 $O(n \cdot n!)$ ,所以总的时间复杂度也为这个。对于答案数组，全排列的个数为n!，每一个需要耗费n空间，所以空间复杂度为 $O(n \cdot n!)$ ，非答案数组中，需要存储是否被访问过(n个)，以及track(长度为n)。为了减少这两个部分的空间消耗，可以直接原地对nums数组操作（官方解法，即解法2）,但是该法的缺点是结果不满足字典序。|
|[78. 子集](https://leetcode.cn/problems/subsets/)|:star2::star2:|`回溯`|[1.回溯](https://leetcode.cn/submissions/detail/420786414/)<br/> [2.二进制](https://leetcode.cn/submissions/detail/420881327/)<br/> [3.迭代法](https://leetcode.cn/submissions/detail/421516927/)<br/> [4.递归](https://leetcode.cn/submissions/detail/421527152/)<br/> [5. 二叉树遍历]()|$O(n2^n)$<br/> $O(n2^n)$<br/> $O(n2^n)$<br/> $O(n2^n)$|$O(n)$<br/> $O(n)$<br/> $O(n)$<br/> $O(n)$||使用回溯时，画出回溯树，为了不重复，每一个元素之后只访问比其大的元素，给人一种需要对nums先排序的感觉，所以我自己实现的时候对nums排序了一下，而且我递归传入backtrack函数的begin参数为begin+1，而不是i+1；标准的实现不用排序，且传入begin 参数的是i+1.对于复杂度，集合元素个数为 $2^n$ ,即状态个数，每一个状态需要 $O(n)$ 复杂度时间得到。空间复杂度为 $O(n)$ ，递归栈为 $O(n)$，临时状态空间为 $O(n)$. 方法二的二进制位思想也很好，集合的子集个数为 $2^n$ ，刚好可以用0~ $2^n-1$ 来表示，问题：如果Nums长度大于32或者64怎么办？从内存以及运行速度考虑，速度肯定慢，内存不一定存的下。方法三和方法四也很妙，两种方法思路一样，实现的方式一个使用迭代，一个用递归，核心思路是每添加一个元素，集合的子集={子集}+{子集+元素}；时间复杂度：外层是nums元素个数，内层=1+1x2+1x2x2...+ $2^n$，一共：O(n(2^{n+1}-1))=O(n2^n)；空间复杂度：不算结果列表，中间会需要将子集复制一份然后添加元素，所以为O(n),用递归方式实现的话会多一个递归栈，总的来说还是O(n)。方法5，对于每一个元素，将其状态分为选和不选，可以构成一个满二叉树，每棵树左子树表示选（或不选），右子树表示不选（或选），然后对二叉树遍历。上面说到的几种方法在[这里](https://leetcode.cn/problems/subsets/solution/er-jin-zhi-wei-zhu-ge-mei-ju-dfssan-chong-si-lu-9c/)可以学习到。|
|[39. 组合总和](https://leetcode.cn/problems/combination-sum/)|:star2::star2:|`回溯`|[1.回溯1](https://leetcode.cn/submissions/detail/422834166/)<br/> [2.官方](https://leetcode.cn/submissions/detail/423857347/)|$O(n2^n+)$<br/> [3.剪枝](https://leetcode.cn/submissions/detail/424546689/)|$O(n)$ ||回溯1是自己实现的方式，在回溯框架下，加一个检查步骤，每次加入新track前检查是否已存在，时间复杂度和空间复杂度受检查方法的影响。第二种方法注意画出回溯树更好理解，官方给出的是递归树是左子树不选，右子树选，不选的情况指针后移，选的情况指针不动，因为可能重复选。还有一个技巧是不要每一次对track.sum()，可以使用target减值然后传入，当target=0时就是一个解。画出树之后就发现每一次递归内不能有循环，如果循环了会重复。然后还可以看[这里](https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/)讲解解法三,解法3的思路是，先对数列表排序，每次选了之后只往后看（也看当前，因为可能重复选），这样可以防止3,2,2情况的出现。其实也可以一开始不排序，然后每次选了之后只往后看，这样和前面方法的区别在于，当遇到target-Num<0的时候，循环得用 continue，而不是break，这里的break在回溯树种体现出来的就是剪枝的效果，而continue只是搜索到了树叶。这类问题的时间复杂度如何分析？|
|[15. 3数之和](https://leetcode.cn/problems/3sum/)|:star2::star2:|`回溯`|[1.回溯超时](https://leetcode.cn/submissions/detail/424555730/)<br/> [2.优化空间复杂度](https://leetcode.cn/submissions/detail/419116598/)<br/> [3.双指针超时](https://leetcode.cn/submissions/detail/427593183/)|$O(n \cdot n!)$<br/>$O(n \cdot n!+2n)$<br/> $O(n^2)$ | $O(n \cdot n!)$<br/>$O(n \cdot n!)$<br/> $O(1)$||递归算法的用时和内存消耗与递归树的节点数紧密相关，递归树的非叶子结点与叶子结点的行为不同。非叶子结点中，第$i$层递归树结点数为 $A^i_{n}$ ，所以仅仅看递归树的深度，每一个叶子结点的计算用时<2n!，而每一个叶子结点中也循环了n次，所以非叶子结点的时间复杂度为 $O(n \cdot n!)$ 。最后一层有n!个叶子结点，每一个叶子结点都要进行一次拷贝，所以叶子结点的用时也为 $O(n \cdot n!)$ ,所以总的时间复杂度也为这个。对于答案数组，全排列的个数为n!，每一个需要耗费n空间，所以空间复杂度为 $O(n \cdot n!)$ ，非答案数组中，需要存储是否被访问过(n个)，以及track(长度为n)。为了减少这两个部分的空间消耗，可以直接原地对nums数组操作（官方解法，即解法2）,但是该法的缺点是结果不满足字典序。3.双指针法思路是，先排序，固定第一个数，然后后俩数只能往后取，固定第二个数，找符合要求的第三个数。但是我自己实现超时。看了一个双指针的解题思路之后重新实现一遍通过，参见[这里](https://leetcode.cn/problems/3sum/submissions/)|
|[1. 两数之和](https://leetcode.cn/problems/permutations/)|:star2:|`回溯`|[1.回溯超时](https://leetcode.cn/problems/two-sum/)<br/> [2.哈希表](https://leetcode.cn/submissions/detail/425156006/)|$O(n \cdot n!)$<br/>$O(n)$ | $O(n)$<br/>$O(n)$||使用回溯超时，但是官方的二重循环却可以通过，这个地方没有想明白为啥，回溯确实本身时间复杂度更高，但是本题中结果列表长度一旦=2就停止继续往下递归，每选取一个数就会继续看这个数的后面是否有数使得结果列表满足要求，所以按理来说两种方法用时一样的。哈希表法的核心思想：将列表的前一部分的补集和该数的索引存入哈希表，等到后面遇到这个数的补集时，直接根据哈希表查找补集的补集的索引|
|[40.组合总和2](https://leetcode.cn/problems/combination-sum-ii/)|:star2::star2:|`回溯`|[1.回溯](https://leetcode.cn/submissions/detail/429721944/)<br/> |$O(n \cdot n!)$<br/> | $O(n)$<br/> ||回溯总体框架不变，难在剪枝，两个难点：数列表中可能有重复元素、结果track如何去重。重复元素可以判断下一个元素是否和前一个元素相等来解决，结果track可以分析递归树，一般这种去重先对数列表排序，然后再处理，在提交的代码中，使用一个变量last完成了元素去重，last存放的是track.pop()，下一次迭代判断选择的元素是否与last相同达到去重元素的效果，同时传入递归函数的指针为i+1，即只往后看从而实现去重track，复杂度分析：空间复杂度除了结果列表，还有递归树的深度+track变量，时间复杂度只能算出上界。|
|[47.全排列2](https://leetcode.cn/problems/permutations-ii/)|:star2::star2:|`回溯`|[1.回溯剪枝](https://leetcode.cn/submissions/detail/430352262/)<br/>  [2.回溯剪枝排序](https://leetcode.cn/submissions/detail/431188694/)|$O(n \cdot n!)$<br/> $O(n \cdot n!)$| $O(n \cdot n!)$<br/> $O(n \cdot n!)$||麻烦在去重，首先要1. 路径前部分用过的数，在后部分不能再使用(使用used变量解决)；然后2. 回溯树中同一层相同的枝叶需要剪掉(使用layer变量解决)。但是有的解法中，只用used变量即可实现2，即先对nums排序，对于排序后的nums要剪掉同一层相同的元素可以直接和上一个append到track的元素比较即可，可以参考：[解法](https://leetcode.cn/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/).[这篇](https://leetcode.cn/problems/permutations-ii/solution/hot-100-47quan-pai-lie-ii-python3-hui-su-kao-lu-zh/)文章的判断条件解析很好。|
|[77.组合](https://leetcode.cn/problems/combinations/)|:star2::star2:|`回溯`|[1.回溯](https://leetcode.cn/submissions/detail/432489416/)<br/> [2.选与不选](https://leetcode.cn/submissions/detail/432655849/)|$O(n \cdot n!)$<br/> $O(k*(n k))$| $O(n)$<br/> $O(n)$||两种方法都是回溯只是思考的角度不同，这里两个效率相差大是因为方法一没有增加剪枝操作，两种方法都增加的话执行的时间差不多。虽说方法一有一个循环，将回溯树画出来的话发现，这里的循环其实是对同一层遍历，这种对同一层的遍历过程在方法2中没有显示提取出来而已，这种方法然后树形结构的空间复杂度和树的高度有关（递归深度）。方法一的思路是，选择一个节点之后，还可以选择哪一些节点，显式用for循环体现出来，方法2的思路是，对每一个节点，若选择了，进入选择后的状态的后续过程；若不选择，进入不选择的状态的后续过程。两种方法的讲解可以看[这篇](https://leetcode.cn/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/)文章, 空间复杂度和递归栈的深度相关。这里方法1的时间复杂度不对，没有将剪枝和树形结构考虑进去|
|[216.组合总和3](https://leetcode.cn/problems/combination-sum-iii/)|:star2::star2:|`回溯`|[1.回溯](https://leetcode.cn/submissions/detail/432489416/)<br/> [2.选与不选](https://leetcode.cn/submissions/detail/432938001/)|$O(n \cdot 2^n)$<br/> $O(k*(n k))$| $O(n)$<br/> $O(n)$||本题的框架和前面题目的框架一样，两种方法：递归内有循环、递归内无循环，有循环的思路是同一层中各个元素的选择，无循环的思路是一个元素选还是不选，时间复杂度上，方法一的时间复杂度为 $O(n*2^n)$ 这里的n是集合的大小。方法2的时间复杂度为组合+存入时间，组合是从n个数中选择k个。|
|[17.电话号码字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)|:star2::star2:|`回溯`|[1.回溯](https://leetcode.cn/submissions/detail/433520394/)<br/> [2.选与不选](https://leetcode.cn/submissions/detail/433219717/) <br/>[3.队列](https://leetcode.cn/submissions/detail/433933131/)|$O(3^M*4^N)$<br/> $O(3^M*4^N)$| $O(n)$<br/> $O(n)$||本题和前面几题没有太大区别，前两种方法都是基于回溯实现的, 队列的想法也很好，先将第一个数对应的所有字母入队，第二个数时，将第一个数的所有字符出队，并与第二个数的所有字母拼接再入队，以此类推。空间复杂度和按键数有关，比如三个按键，每个按键都是3个字母，则为27. 时间复杂度一样如此|
|[131.分割子串](https://leetcode.cn/problems/palindrome-partitioning/)|:star2::star2:|`回溯`|[1.回溯](https://leetcode.cn/submissions/detail/439102324/)<br/> [2.回溯+动归](https://leetcode.cn/submissions/detail/439170960/) <br/> [3.回溯+记忆搜索](https://leetcode.cn/submissions/detail/439375945/)| $O(n*2^n*n)$ <br/> $O(n*2^n)$ <br/> $O(n*2^n)$ | $O(n) <br/> $O(2^n)$ <br/> $O(2^n)$||本题转化为回溯的思路很重要，最初我自己的思路是对切割的位置回溯，但是没有顾及切割的位置，想着是切割位置可以在任何地方，所以问题变得非常复杂，参考结题思路后，将分割子串看作一系列按顺序切割的问题：解法一中，从左往右，先切第一个子串出来，如果不是回文（双指针法判断），切割位置右移直到是回文子串为止，切割完第一个，接着切割第二个，然后回溯第一个切割的位置。如果切割位置到了字符串末尾，结束。时间复杂度和空间复杂度参考官方分析,空间复杂度不考虑结果列表的话，主要和递归深度有关，递归深度空间复杂度和字符串长度以及含有的最长回文子串有关，所以复杂度为 $O(n)$ 。方法2的思路是，判断字符串是否为回文子串的过程用双指针会有重复计算（字符串之间有重复），然后使用动归来解决。空间复杂度和动归的helper有关，即为 $O(n^2)$ . 方法3的记忆化搜索其实是用一个修饰器修饰一个函数，将该函数的结果存储起来，当输入的参数相同时，直接返回缓存的结果，类似动归|
|[93.复原ip地址](https://leetcode.cn/problems/restore-ip-addresses/)|:star2::star2:|`回溯`|[1.回溯](https://leetcode.cn/submissions/detail/441400199/)<br/>[2.]()|$O(3^4*n)$<br/>$O()$ | $O(1)$<br/>$O()$||回溯还是先自己画出树，然后可以容易分析出时间复杂度和空间复杂度，甚至剪枝。回溯解法的时间复杂度容易忽略要将结果写入结果数组，这也会花时间。本题这里给出的解法没有任何剪枝操作，是最朴素的版本。|
|[491.递增子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)|:star2::star2:|`回溯`|[1.回溯](https://leetcode.cn/submissions/detail/441575204/)<br/>[2.]()|$O(3^4*n)$<br/>$O()$ | $O(1)$<br/>$O()$||本题核心在如何去重，同一层去重，不同层不用去重，因为结果序列会将一整条从根节点到当前节点的路径取出来，不涉及不同层的重复问题（根都不同了肯定序列不同，而控制根不同的就是同一层去重的问题了）。|

